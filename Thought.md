# 食用声明

PA实验的版本为ics2019，具体参考实验手册[南大2019PA实验](https://nju-projectn.github.io/ics-pa-gitbook/ics2019/)。后续的标题与该实验手册的目录是相对应的。

此处关闭了原PA的开发跟踪，采用原生的git方式一步步提交相应的改动，[关闭方式参考](https://nju-projectn.github.io/ics-pa-gitbook/ics2019/0.6.html)。

这里记录了PA实验过程中的思考和`git log`跟踪目录，具体可以通过`git reset`的方式，或查看commit记录回到当时提交的时间节点，查看相应的改动。查看改动的方式可以使用`git diff`。

谢谢食用。

（一刷走的是x86的路线）

# 基本环境

系统环境：虚拟机vbox + debian，其中vbox是6.0.14版本（不太建议，因为要安一些麻烦的拓展工具），debian是10.3.0版本。docker用起来比较麻烦，所以比较推荐使用vbox。主机环境为win10，cpu和内存影响不是很大。在一切就绪后debian默认应该是800\*600分辨率，偏小，建议调成1280\*800以上（在桌面右键Application/Settings/Display中设置）。

操作环境：tmux + vim。其中tmux在PA中有链接教学，相比于多终端我更喜欢使用tmux切换和分屏查看代码和执行程序。vim按照PA修改配置即可，够用就行。多依赖键盘而不是鼠标可以在一定程度上提高效率，但不强求，毕竟需要有一定vim的功底和命令行的基础。

# 通过PA能收获什么

其实依我个人的看法，凡是学习或涉及到**指令**和**程序**（包括计算机、单片机、FPGA，或者指硬件层面）的专业，都很有必要做一遍PA，因为它能够帮你迅速且全面地掌握系统、架构、编译相关的知识，通过实操使你的印象更加深刻，也充分锻炼了debug即解决问题的能力。除此之外，RTFSC、RTFM、RTFW等获取信息的能力也会得到极大的提升。这是从硬件与软件的中间层，即系统层这种极为基础的层次了解一个系统与环境的基本构成与实现，这对于相关专业都是极为有意义的。

# PA0

基础知识，跟着实验走即可。

# PA1

未完待续。

## PA1-3

> Reorganize the structure "CPU_state" (`nemu/src/isa/x86/include/isa/reg.h`).

这里需要查阅i386指令手册中的寄存器编码方案，具体在[INTEL 80386](http://css.csail.mit.edu/6.858/2013/readings/i386.pdf)中的31页（2.3.2节），也可以参考实验手册给出的x86寄存器结构。

寄存器分为3类，32位、16位、8位，且物理上不是独立的，即其是共享一块内存的。从命名方式也可以看出，如EAX是32位，其低16位是AX，AX中分为高8位（AH，H->high）和低8位（AL，L->low）。

**根据共享内存这一条件可以想到使用union**，通过将3类寄存器用union而非struct的方式定义，可以实现上述的寄存器设计。关于union可STFW获取更多信息。

在修改代码前先查看相应的测试代码(`nemu/src/isa/x86/reg.c`中的`reg_test()`)，查看assert的相关条件。可以看出其先随机给32位的寄存器赋值，然后通过assert判断32位寄存器中低16位和16位中的高低8位的值是否与对应的寄存器中存放的值相等。这与x86寄存器的设计以及上述思考是一致的。因此上述实现可以通过第一部分的assert测试。

此外在测试代码中还可以发现，其第二部分的assert测试是直接调用cpu.eax的方式访问相应的寄存器，即32位寄存器在cpu中有着类似cache的方式，有直接的变量对应，可以直接访问。因此回到`reg.h`的头文件中，需要再用一个union将相应的变量定义(eax等）与上述union定义的3类寄存器包含，使其也共享同一块内存空间。

如果此时直接运行测试，会发现assert会在第二部分的第二条语句触发。因为cpu.eax等的定义是`uint32`，相当于在union中连续声明8个uint32，了解过union共享内存的方式可以得知eax，ecx等寄存器在此时对应的都是同一个内存块（即`reg[0]`），因此eax可以pass第一个assert，但ecx由于对应的是eax的值，因此无法pass第二个assert。这里的解决方式很简单，只需要用一个struct将uint32的连续声明括住，定义一个大的结构体来表明其是一个整体而非互不相关的变量即可，此时的struct将与另一个union共享32\*8的内存空间，而在struct内部则是按顺序连续分配32字节的内存块，可以实现一一对应。

到这里就可以执行make run的指令并通过reg的所有测试，启动nemu了。

git log: `0a61a1821ee0a44b0171e5b154d8ecbccce748db`

小结：1、熟悉了x86指令集的cpu寄存器结构。 2、熟悉了union的原理和使用方式。 3、根据测试代码进行分析与修改。

>> 调用`cpu_exec()`时传入参数`-1`.

注意到其形参是`uint64_t`，传入`-1`意味着其可执行无符号64位数所支持的最大数的指令数（内置有一个循环，循环次数为可执行的指令数）。在C99中已有对64位整型数的支持，当给`uint64`赋值为-1时，其为`uint64_MAX - 1`，当然前提是平台支持64位。

## PA1-4

> 实现单步执行，打印寄存器，扫描内存的debug功能。（`nemu/src/monitor/debug/ui.c`）

单步执行只需要调用cpu_exec，传入相应的参数即可。

打印寄存器使用strtok分离出子参数，根据子参数进入打印寄存器的条件块，调用ISA的API即可。这里选择的是x86，因此需要在`nemu/src/isa/x86/reg.c`中完善相应api的代码。打印方式可以参考相应的测试代码，以及使用`reg.h`头文件中定义的函数和声明的变量数组。

扫描内存同样用strtok分别分离出两个子参数，这里先将EXPR暂时规定为十六进制而非表达式。访问内存数据的方式参考`nemu/include/memory/memory.h`中定义的宏和函数，直接调用即可(相关代码文件包括`nemu/src/isa/x86/mmu.c`以及`nemu/src/memory/memory.c`)。其中形参len指代的是字节的长度(详见`memory.c`)。输出格式参考命令`si`的输出。

git log: `6247203359e269e0e2a466579f03aaf93d78be9d`

小结：1、熟悉使用strtok处理命令的参数。 2、熟悉monitor中debugger的框架。

## PA1-5

> 实现算术表达式的词法分析（`nemu/src/monitor/debug/expr.c`)

代码实现可分为两部分，第一部分是定义，第二部分是功能实现。

在定义中，包括TOKEN类型值的定义，以及TOKEN规则的定义。根据词法分析一开始给出的表达式例子，在这里实现加（ADD）、减（SUB）、乘（MUL）、除（DIV）、十六进制（HEX）、指针解引用（DEREF）、小括号（LP、RP）、数字（NUM）、变量（VAR）、寄存器（REG）等基本定义以及根据其定义的equal符号（==），补充不等（NEQ）、非（NOT）、与（AND）、或（OR）等逻辑符号，最后用正则表达式定义相应的规则即可。

（不过此处为了简单起见，负数的处理在后续内容中暂不涉及，正如KISS法则，先实现简单的功能，让其能够run起来。在此基础上，遇到有更多功能的需求时也可以很方便的参考写出相应的代码。一开始就面面俱到只会让自己头大，并写出满目疮痍BUG频出的代码。）

**注意1**：由于循环中是按照规则定义的顺序来匹配字符串的，因此有冲突的正则定义需要有正确的顺序（比如HEX与NUM，NEQ和NOT等）。

**注意2**：在`enum`中定义TOKEN类型值的时候是顺序递增的，此处为了方便对常用的加（ADD）等符号直接用相应符号的ASCII值，定义完常用符号后需要恢复原来的排序值。

**注意3**：c的`regex`不支持`\d`正则匹配，可用`[0-9]`的方式来替代。

在功能实现部分，需要对表达式进行词法分析，简单来说就是将表达式中的所有符号和数字一一分离并保存。在框架代码中已经通过循环的方式用规则匹配并识别出了相应的token，后续只需要将这些token存至数组中即可。对于几种特殊的类型，即`HEX`、`NUM`、`VAR`、`REG`，需要记录其字符串，以便在后续对其值进行分析，而一般的符号只需要记录其符号类型即可判断其作用。

**注意4**：使用`assert`的方式拦截缓冲区溢出的情况。

后续可通过打印token数组的方式对实现进行调试。

git log: `e4a738a8ba160ecd490592268bf2706861217b65`

> 实现算术表达式的递归求值

在实验手册中已有BNF的解释说明与实现框架，只需要根据BNF的定义说明填充框架内的细节代码并补充部分必要的函数功能即可。这里通过传入`success`指针的方式来做相应的错误处理并提前结束求值过程，包括括号匹配的问题以及其他的一些非法表达式。

在做算术表达式求值前，通过`check_deref`的方式提前将乘（MUL）与解引用（DEREF）分开，具体的判断方式是解引用符号是第一个token或前面一个token是操作符而非数值。

负数求值选做留至2周目。（负数符号与解引用符号是类似的，识别方式相同，处理方式类似）

**注意1**：要考虑到只有一个解引用作为主运算符的情况，此时左式val1不存在，右式仅有一个数值或变量val2作为指针地址。（非运算符同理）

git log: `fb0f64b47a5854131d9e2dbd887dea4ffec34d61`

> 随机测试，实现表达式生成器

本身的框架和代码并不复杂，是很简单的功能，较复杂的结果计算与保存已经有相应的代码实现。而需要注意的要求有：

**注意1**：长表达式buf的溢出判断。

**注意2**：随机插入空格的方式。这里仅实现插入0或1个空格。

**注意3**：除0行为。由于结果是`uint32_t`即无符号的32位整型数，因此除法很容易带来除0的情况。为了减少这种无效的表达式，可以将生成除号的概率降低。

**注意4**：保证表达式进行无符号运算。

>> 为什么要使用无符号类型？

一个是溢出的问题，第二个是在表达式求值没有需要用到负数结果的情况。进行有符号运算可能会出现非法或溢出的问题。

举例来说，如果是`8 bit`的`unsigned`，在数据超过`2^8`时会取余（实际上是不断轮回到0直到其在表达范围内），包括出现负数时也会用`2^8`减去相应的值，可以将其看成是一个由数值范围组成的圆。而对于`8 bit`的`signed`，超出范围即溢出时不会做求余运算，在C中的定义是`Undefined Overflow`，由于最高位是符号位，因此会在截断多余的高位后进行符号判断，决定是否采用补码。

>> 除0的确切行为。

当出现除0行为的表达式，如`123 / (456 / (789))`，表达式生成器依旧会将其嵌入至求值代码中。此时求值结果会报`warning: division by zero`，而输出至input中的计算结果是上一次计算的结果，显然结果是错误的。因为除0行为的算式没有求值结果，表达式生成器便会用`result`变量原本的值输出。因此需要过滤除0行为的表达式，否则会出错。

**注意5**：除了需要过滤除0行为的表达式，溢出的表达式也应过滤，即求值“计算器”不处理溢出的表达式。

>> 过滤除0行为的表达式。

其中一个解决方案是在表达式求值的调用代码中操作。第二个解决方案是直接在表达式求值的代码中操作。归根结底都是对除0的报错做相应的处理。但过滤溢出行为只能采用后者的方法，通过返回特殊的值进行处理。

这里做过滤除0的工作，溢出过滤比较麻烦，这里暂不实现。

有两种方法可以过滤除0，一个是采用`system`的方式先执行一遍“计算器”程序，如果不是正常返回说明是无效的除0表达式，过滤后重新生成表达式即可。但由于system会输出合法表达式的结果，因此需要在后续将结果打印至文件中，即通过`FILE`的形式使用`fputs`，而非使用`printf`后在shell中调用`./gen-expr [amount] > input`命令将程序打印的输出保存至`input`文件中。

为了保留原本程序的特性，即使用`> input`的方式保存相应的结果和表达式，这里采用第二种方法，即对`popen`打开管道中的内容进行判断。通过代码调试和分析可以发现，不能直接调用`feof`来判断是否出现了除0等非法行为导致没有输出，因为对于合法表达式和除0表达式，`feof`均输出0，即没有到文件结尾。原因是即使程序没有输出，在`popen`的管道中仍会存在字符串的结尾`\0`。故这里通过`getc`的方式读取第一个字符，判断其是否是`EOF`来进而判断其是否正确执行了计算（从而过滤除0）。当然也可以先执行`getc`将第一个字符读出后再调用`feof`判断是否到了文件结尾，对于无输出的情况，其会将`\0`先读出，此时到了文件结尾`feof`会输出非0值；对于有输出的情况，即使只有一个个位数，其也会因为残余`\0`而未到文件结尾，`feof`输出0值。

需要注意的是由于使用了`getc`读取了第一个字符，因此需要重新回到文件开头读取正确的结果。

**注意6**：`rewind`不适合在`popen`中使用，在stack overflow中有相应的[问题](https://stackoverflow.com/questions/19523806/using-rewind-with-popen)，因为`rewind`是特殊的`fseek`，而`fseek`仅适用于文件而不适用于流，故`popen`的管道（也是流）是无法通过`rewind`的方式回到开头的。如果检查`rewind`的errno也可以发现这一点。事实上，由于管道是一小块内存缓冲，只存放临时产生的数据，因此无法使用`seek`。若要回到文件开头，这里采用的方式是关闭原来的管道并重新创建新管道。

>> 完善测试与实现和完善debugger中的表达式功能

在`input`文件中生成了表达式与结果后，在`nemu/src/main.c`中编写相应的测试函数，并在main入口主函数中调用该测试函数即可。根据测试的结果对原来的实现进行分析，修复隐藏的bug。

*通过这种方式确实找出了一个没报错的隐藏bug，这个bug在正常情况下也不会触发，但在表达式出现多个括号的情况下就可能出现。bug是在找主运算符中对括号的处理上出现了问题，具体可以通过`git log`以及`git diff`查看相应的改动。*

到此时PA1-5求值表达式的功能实现与完整测试已经完成，只需要在之前留空的PA1-4-debugger中补充相应表达式功能即可。包括：

1. 实现`cmd_p`的表达式求值功能。
1. 将`cmd_x`扫描内存中暂用的16进制数替换成`EXPR`即表达式求值，用所求的值作为扫描的内存地址。

git log: `ea31260b2bba64e609e0c39350926248f64e9bd1`

## PA1-6

> 扩展表达式求值的功能

这部分工作在PA1-5中已经基本完成。值得注意的是在PA1-5中寄存器的求值处理在这里需要做一点改变，将其抽象至ISA中，直接调用ISA的API来获取相应的值。具体的实现工作放在ISA的API中去做。

git log: `c0abf3e3d6cc8aa3352d9121f2e8013810daf7c6`

> 实现监视点池的管理

主要是链表的插入与删除操作（为了方便删除操作的参数使用监视点序号n）。(`nemu/src/monitor/debug/watchpoint.c`)

>> static的含义，为什么使用。

在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

> 实现监视点

首先需要确定监视点所监视的对象，即在监视点结构中需要加入什么监视变量。这里需要记录的对象有表达式以及表达式的值（或称为未发生改变的旧值）。(`nemu/include/monitor/watchpoint.h`)

随后需要新增监视点对应的功能函数，包括两方面：(`nemu/src/monitor/debug/watchpoint.c`)

1. 每执行一条指令，需要调用函数1来对监视的表达式求值，比较其是否发生变化。若发生变化，则暂停程序。
1. 在调用命令`info w`时需要调用函数2，以打印监视点中的详细信息。

确定好需求和目标后实现起来并不困难，只需要按照要求完成即可。

最后在PA1-4的debugger中更新与监视点相关的功能。（`nemu/src/monitor/debug/ui.c`）

需要注意的是，因为要在执行指令的过程中检查监视点的值是否发生变化，因此需要在`cpu_exec`中植入与监视点相关的检查代码。（`nemu/src/monitor/cpu-exec.c`）

git log: `xx`

> 调试工具与原理

一些很有用的调试方式与建议，GDB也很强大。

>> 在GDB中运行触发段错误的程序，会提供什么信息？

关于段错误可以参考[百科](https://baike.baidu.com/item/%E6%AE%B5%E9%94%99%E8%AF%AF/7896410?fr=aladdin)，GDB会提供以下信息：

1. 程序触发的错误类型（段错误），接收到什么信号而终止的程序（可以通过man 7 signal查询对应信号）。
1. 触发错误的具体位置，即源文件的行数、所在的函数、函数的地址。
1. 触发错误对应行的详细代码。

可以看出GDB的强大作用，在`assert`和`printf`不管用的情况下，GDB是很好的选择。

> 断点

该篇提到了用监视点来模拟断点的功能，以方便查看程序在某一时刻的状态。值得注意的是，断点地址仅能设置在每条完整指令的开头，设置在中间时会跳过，实际上用`si`单步执行指令时也可以发现这一点。当然这是合理的，且不论实际的编译调试就是如此，更深入地看，不同的指令有不同的字节长度，而每次执行完指令寄存器PC都会跳到下一条指令的地址，而不是下一个字节。

>> 提高断点的效率

设置断点会明显降低NEMU执行程序的效率，这是显然的。因为每执行一次指令都需要检查所有的监视点，而检查的过程包括对表达式的一次求值，这个过程相比于执行单条指令是慢很多的，因此会大大降低执行效率（甚至可能是10%的时间在执行指令，90%的时间在检查断点）。可以很容易的发现断点的效率之所以非常低下，归根结底是因为断点是用监视点来模拟的，为了解决这个问题，则需要从根源着手。监视点本身相比于断点是低效的，因此需要将断点与监视点的功能分离开来。类似于debugger中x86的`int 3`断点中断指令，在设置断点的时候，需要将断点目的地址的数据保存起来，然后将指令的第一个字节码替换成对应的中断指令（`0xCC`)，由CPU自己产生中断而不需要像监视点一样每条指令都进行扫描。

具体方法不难，只需要设置对应的断点地址，用框架内置已实现的`vaddr_read`将地址内的指令数据读出，再用`(data & 0xFFFFFF00) | 0xCC`(因为这里一次读了4个字节)后`vaddr_write`写回即可，遇到断点暂停后再将原数据写回（这一步则需要在`cpu-exec.c`中完成，与监视点的暂停实现类似）。

>> 一点也不能长以及随心所欲的断点

`int 3`指令长度是1个字节，这是必须的。指令的长度变成了2个字节后文章中所说的断点机制就不再能正常工作了，并非指的是程序无法在断点处停下，而是如果需要在单字节指令处设置断点（如汇编中的`DEC/INC`），意味着下一条指令的首字节会被覆盖而改变原意，导致无效的指令，具体案例可以参考[这里]的**More on int 3**小节。

如果把断点设置在指令的非首字节，即中间或者末尾，那么在GDB中程序并不会在断点处停下，这与我们之前实现的监视点形式的断点是类似的。原因在前面已经提到，CPU在执行指令的过程中会先读PC寄存器指向地址的第一个字节，即操作码，在未遇到`int 3`这类中断暂停的单字节指令时程序会继续执行，而植入在中间或末尾的断点只会改变操作码后面的字节数据，造成错误的结果。

举个例子，当指令为`mov ebx, 1`时，机器的字节码为`bb 01 00 00 00 | mov $0x1, %ebx`，这是一个5字节长度的指令，如果将首字节的`0xbb`替换为`0xcc`，将引入一个`int 3`断点中断。当断点设置在非首字节，如将`0x01`替换为`0xcc`，则指令的原意将发生改变，且不会触发中断暂停程序。

## PA1-7

使用的ISA为x86，按照假设需要在调试上花费时间75小时。简易调试器花费25小时，节省50小时，事实上使用GDB直接调试客户程序需要的时间可能更长，相比于简易调试器而言更难且效率更低。

通过查阅[x86手册](http://css.csail.mit.edu/6.858/2013/readings/i386.pdf)可以得到以下问题的答案：

1. EFLAGS寄存器中的CF位是“Carry Flag”，是进位或借位标志位，在计算前后会对其进行处理。具体解释在3.2节，EFLAGS寄存器结构图在2.3.4节的图2-8。
1. ModR/M字节是用于指示操作数是在寄存器中还是在内存中。具体参考2.5.3节。
1. mov指令的具体格式是MOV [DEST], [SRC]。具体参考17.2.2.11节。

shell命令可以统计代码行数，包括除去空行时的行数。命令为：`find . -name "*.[ch]" | xargs cat | wc -l`，除去空行则在`wc -l`前加上`grep -v ^$`和管道即可。至于在PA1编写了多少代码，只需要通过`git log`以及`git reset`回到相应的历史版本即可，或者通过`git checkout master`回到最初的pa master分支，因为此时还没合并分支，即分支pa1是超前的，因此可以通过比较分支pa1的代码行数以及分支master的代码行数来统计在PA1中编写了多少代码。可将上述统计代码行数的命令加入Makefile中。

git log: `xx`

在GCC的编译选项中，`-Wall`和`-Werror`分别是打开GCC的所有警告，以及将所有警告当成错误进行处理。使用这两者可以对编译过程中可能存在的问题进行检查，通过error的方式找出这些问题，而不会被忽略成为隐患。

到这里PA1的内容已经结束。基本的调试与模拟工具NEMU已基本实现，为之后的PA打好了基础。

# PA2

未完待续。

## PA2-2

> RTFM，找手册指令集内容的位置 （x86）

每一条指令具体行为的描述： P255标题为17.2.2.11 Instruction Set Detail。之后很长一段都是描述各个指令的具体行为。

指令opcode的编码表格： P412标题为Appendix A Opcode Map。附录开头给出简写定义，P414-P416给出编码表格。

> RTFSC2, 整理一条指令在NEMU中的执行过程

1. 取指令，在`/include/cpu/exec.h`中调用函数`instr_fetch`，通过访问相应长度（`len`）的内存地址（`pc`）将指令（的值，即机器码）取出并返回。

1. 译码与执行，根据取出指令的机器码，通过翻译其操作码`opcode`来决定指令对应的具体操作`OpcodeEntry`元素。在`include/cpu/exec.h`中的`idex`函数抽象出了译码与执行的两个过程，从译码查找表中取得的元素（或称之为辅助函数，包含译码辅助函数和执行辅助函数）会被作为参数进行调用。

1. 译码的具体细节，找出操作码后还需要找出操作对象，这就涉及到了译码辅助函数，在`include/cpu/decode.h`中统一通过宏`make_DHelper`来抽象定义，不同的译码辅助函数负责单独一种的操作数译码。为了进一步解耦出操作数译码和指令译码，还额外使用了宏`makeDopHelper`来专门抽象定义操作数译码的辅助函数，该宏和相应的函数在`src/isa/x86/decode/decode.c`中定义（因为这是ISA相关的内容，具体原因请查看讲义的蓝框背景说明）。

1. 执行的具体过程，在`include/cpu/exec.h`中也定义了相应的执行辅助函数的宏`make_EHelper`，而执行辅助函数内具体通过RTL（寄存器传输语言）指令来真正执行对应的指令。关于RTL的行为定义，在`include/rtl`中包含了`rtl.h`以及`c_op.h`，对应的RTL寄存器则在`include/cpu/decode.h`以及ISA相关的`src/isa/x86/include/isa/reg.h`中定义，还有供中间操作的临时寄存器(`src/cpu/cpu.c`)。

1. 更新PC，根据执行指令的长度，更新`pc`至下一条指令的地址。

> 运行第一个C程序

>> 报错信息的来源

在nemu的文件目录下查找源码中含有的关键字即可，`find ./ -type f | xargs grep -n "invalid opcode"`可以发现是在`src/isa/x86/exec/special.c`的第17行输出的报错信息。更具体的，后续调用的`display_inv_msg`的invalid函数则是在`src/cpu/inv.c`中定义的。

>> 指令的实现

首先根据上述RTFSC2的问题可以知道执行指令的入口在`idex`函数处，这部分会调用两个辅助函数来完成译码与执行两部分工作。而在这之前我们需要考虑的是操作码的识别与索引`opcode_table`找出相应的`OpcodeEntry`元素这两个过程。通过查看`src/isa/x86/exec/exec.c`的`isa_exec`函数我们可以发现，操作码的识别（即取出当前pc指向地址的第一个字节作为操作码），以及操作码的译码表索引（源码中为`opcode_table[opcode]`）已经在nemu的框架内实现。跟着源码前进我们可以发现我们需要补充实现的部分为opcode_table的填充，为其补上相应的`OpcodeEntry`元素，更准确的说，通过查看`OpcodeEntry`元素的结构（在`include/cpu/exec.h`中），我们需要给出该操作码对应的两个辅助函数以及相应操作数的宽度。

KISS法则，这里仅实现dummy中必要的指令。注意到`include/cpu/exec.h`中定义的宏`IDEXW`与`IDEX`可以很方便地初始化生成`OpcodeEntry`元素，仅需要填入对应操作的函数名字与操作数宽度。此外还有`EXW`, `EX`和`EMPTY`。

接下来查看反汇编结果，发现其涉及的操作码有（这里省去0x）bd, bc, e8, 90, 31, c3, 55, 89, 83, 68, d6, eb，其中框架代码未实现的为e8, 90, 31, c3, 55, 68, eb。不过90是`nop`即无操作，eb对应的`jmp`是在`(bad)`后面，即函数无法正确返回时执行的操作。因此如果仅仅是让dummy程序跑起来，只需要实现e8, 31, c3, 55, 68即`call`, `xor`, `ret`, `push`。其中`push`有两种形式，寄存器和立即数。此外，83的`sub`虽然表中已经实现，但需要额外在`src/isa/x86/include/isa/reg.h`寄存器结构体中添加EFLAGS寄存器。

译码辅助函数的实现在`src/isa/x86/decode/decode.c`中。实现的过程中需要参考之前提到的i386的opcode编码表格和指令的具体行为描述，且仔细思考后会发现慢慢能看懂P412之后的几个表格。这里给出各个指令除填表外涉及到的函数。（在`src/isa/x86/include/isa/decode.h`头文件中列出了所有decode函数）

1. 实现`call`，i386（后略）的P275可以看到e8对应的rel32的指令，找到Operation部分发现需要先将当前`pc`压入栈中保存（事实也是如此），因此需要先实现压栈的rtl。

1. 实现`xor`。P414可知操作码31涉及`make_DopHelper(G2E)`，已实现，填表时直接调用即可。注意到`xor`得出的结果需要覆盖（replace）第一个操作数，在这里指的是`id_dest`的内存地址/寄存器的值，而非操作数的临时内容`val`。部分EFLAGS也需要更新。

1. 实现`ret`。直接调用ret的执行辅助函数即可，无需额外译码辅助。

1. 实现`push`。涉及`make_DopHelper(I)`和`make_DopHelper(r)`，均已实现，可以直接调用，填表即可。值得注意的是，由于rtl支持的栈操作`push`与`pop`均使用4字节，因此在调用`exec_push`时需要先做符号扩展`rtl_sext`，将操作数扩展至32位。

1. 实现`sub`。涉及`make_DopHelper(SI)`, `rtl_sext`。注意到在`make_DopHelper(SI)`已经默认参数`load_val`为`true`了，直接执行了`rtl_li`操作，且`op->simm`为`int32_t`类型。

执行辅助函数的实现在`src/isa/x86/exec`整个文件夹中，包括`special.c`给出了`nop`, `inv`, `nemu_trap`等特殊操作；`control.c`给出了`jmp`, `jcc`, `jmp_rm`, `call`, `call_rm`, `ret`, `ret_imm`等控制操作；`system.c`给出`lidt`, `mov_r2cr`, `mov_cr2r`, `int`, `iret`, `in`, `out`等系统操作；剩余`arith.c`为数学操作，`logic.c`为逻辑操作，`data-mov.c`为数据移动相关操作。很多都留空需要实现相关的代码才能正常运作。

在译码表填充完毕后，剩下的事就是找到相应的RTL指令函数（`include/rtl/rtl.h`以及`src/isa/x86/include/isa/rtl.h`），实现执行辅助函数调用的相关部分，然后运行。

额外需要注意的是，`sub`或之后要实现的`add`都会涉及到`CF`进/借位位和`OF`溢出位的判断。其中`CF`主要针对的是无符号数，而`OF`主要针对的是有符号数。无符号数不会发生溢出问题，只会出现进位，即只管`CF`；有符号数“不会”出现进位（因为最高位已经是符号位了），只会发生溢出问题，即只管`OF`。事实上，有符号数也会出现进位（发生在两个负数相加且未溢出时），此时进位得到的是新的符号位，增加了负数表达的位数，但实际上该进位位没有任何意义。

`CF`进位发生在结果比操作数小，借位发生在结果比操作数大的情况下。`OF`溢出发生在两个源操作数符号位一致，但结果与源操作数符号位不一致的情况下。

此外，参考i386手册会发现部分情况下`src`操作数需要做符号扩展`sext`(在`dest`和`src`位数不同的时候），但在实际执行操作（执行辅助函数）中并不需要额外再做这一步，因为这一步已经在操作数译码辅助函数中完成了（`Make_DopHelper(SI)`），凡是涉及到符号扩展的都会调用`SI`的方式读取立即数。（如果细心点，可以发现在`exec.c`的译码表中，只有6b和83两个操作码涉及到了`SI`操作，而83对应的是gp1的指令表，gp1中包含了所有涉及到符号扩展的数学/逻辑指令，他们对应的操作码实际上也就是83）

git log: `xx`

## PA2-3

> 运行更多的程序 （完善nemu中的代码，实现更多的指令）

没什么好说的，之前已经走过一遍流程了，无非是对未实现的译码、执行辅助函数做填空题。值得一提的是，为了边做边测找问题，而不是全部实现了才进行测试，这里有按一定的顺序编译程序查看其反汇编的机器码，然后对应实现相应的指令（顺序不固定，但最好是从简单到复杂，从少到多）：

1. `add.c`。需要实现的指令数量不大，且实现完后可以将涉及到指令的源码都基本过一遍，有一定的认识和理解，后续再实现其他指令时可以更快更高效的完成。主要有`setcc`、`inc`、`add`等，对应的git log为`xx`。

1. 基本没啥问题了，直接先撸掉操作码的译码表，包括group部分，中间遇到什么未实现的执行辅助函数再跳到`exec`文件夹中去实现。从头到尾一个个去实现，实现完了再去做各个程序的总测试，看报错消息来修正bug。

值得注意一下的是，先前我们已经分析了一条指令的执行过程，其中**取指部分只需要完成译码表的部分**，操作数译码部分在框架中和之前的`dummy`后已经全部实现，**执行部分则需要到`isa/exec`文件夹中去逐个将`.c`文件中的函数全部实现**，rtl部分在`add.c`程序执行完成后已经基本完成了。此外，由于nemu中不涉及segment，因此诸如CS、DS、ES、FS、GS等带S的segments所涉及的指令我们也无需去实现。

（小陷阱：group中的不全是`EX`执行辅助函数，group3在译码阶段会先调用`E`读取`modR/M`到`id_dest`中，这对于group3中的绝大多数指令是没问题的，都是单操作数，但其中第一个指令`test`如果翻阅i386手册的指令解释会发现其没有单操作数的例子，即其仍需再读入一个操作数。在`decode.c`中也可以找到`test_I`的译码辅助函数，注释解释其是专门用在group3中的`test`的。因此group3中的`test`指令仍需调用一次`IDEX`而非只用`EX`。这个小陷阱是测试出现“未实现指令”报错时，查看日志log发现的，你也可以去试试看这个debug找错的过程：group3中的`test`指令使用`EX`，测试的程序对象为`leap-year`，`run`之后会出现“1000be处未实现指令（d8）”，而实际上d8是没有指令的，因此可以初步判断是之前的指令读取操作数的时候发生了错位（读多或读少），找到`build/nemu-log.txt`对照`build/leap-year.txt`的反汇编文本就可以发现问题出在哪个位置的哪个操作码上。）

git log: `xx`

>  实现常用的库函数

实际上只有两个文件需要实现其中的部分函数，也不需要再考虑nemu等底层硬件的调用，而是在C语言的层面上实现一些简单常用的库函数，没什么太大的难度。唯一有一点难度的是需要`man stdarg`查看相关宏如何调用，以及`man printf`查看相关函数的调用参数以及返回值是什么，但实际上翻到最底下看`return`和`example`部分就能快速入手了。

这一小节的目的是为了说明这些库函数实际上是与硬件无关的，只是将一些循环和基本操作封装在一个函数中，这些函数再封装成库，方便其他程序的调用。而无论那些程序是运行在x86还是mips上，都不会影响这些库函数的表现，因此我们仅需要实现这一份代码就可以用在所有的架构上了。

>> 免责声明部分

我们可以看到很多函数虽然没有实现，但都写好了返回值保证这些库函数可以执行。但目前我们用不上所有的函数，只需要实现部分即可。而免责声明提出定义了API不一定来得及把它们全部实现，但将来用到没有实现的库函数debug的时候会非常痛苦，需要花费大量时间去调试，我们需要的是当我们用到了某个没有实现的函数时能够及时提醒。因此如果查看git log的改动可以发现，我们可以在暂时不想实现的函数中加上`assert(0)`来引发报错，将来如果用到了这个函数，我们可以在报错信息中找到具体的文件和行数。（类似的，也可以自己定义一个输出宏，输出相关的未实现信息）

git log: `xx`

## PA2-4

>> DiffTest

首先是需要检查寄存器排列的顺序是否满足API的约束，对比文件为：`nemu/tools/qemu-diff/src/isa/x86/include/isa.h`与`nemu/src/isa/x86/include/isa/reg.h`。其次还可以查看`nemu/src/isa/x86/include/isa/diff-test.h`中定义的`DIFFTEST_REG_SIZE`为9，即这里只检查8个通用寄存器和PC的值是否相同，eflags是不参与检查的（事实上也没办法检查，因为我们在nemu中实现的标志位有限，正常对比结果一般都是不同的）。

接着实现DiffTest中的ISA相关的`checkregs`函数，并在`nemu/include/common.h`中将宏`DIFF_TEST`打开，重新在nemu文件夹下make即可。

如果之前实现的都是正确的指令，那么每次执行完程序都会输出“HIT GOOD TRAP”，并自动退出nemu以及qemu。此外也可以看到输出的字段中有“Differential testing: ON”字样。

（另外，如果想看一下DiffTest的效果，可以将译码表中的31对应执行辅助函数的`xor`改成`and`，然后在nexus-am的cputest中测试add程序。这时候nemu会及时在寄存器值不一致的时候打断程序，并输出所有通用寄存器和对应下一个pc的值，以及发生异常中断的pc位置，此时可以去build中找到程序对应的txt反汇编码，找到相应pc位置，查看其指令，从而定位错误的大致位置。）

git log: `xx`

## PA2-5



# 参考资料

[ICS2019-PA](https://nju-projectn.github.io/ics-pa-gitbook/ics2019/)
[源码分析](https://stardustdl.github.io/ProblemSolving/2018/10/05/solving/nju-icspa-analytics-nemu/)