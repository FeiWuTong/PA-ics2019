# 食用声明

PA实验的版本为ics2019，具体参考实验手册[南大2019PA实验](https://nju-projectn.github.io/ics-pa-gitbook/ics2019/)。后续的标题与该实验手册的目录是相对应的。

此处关闭了原PA的开发跟踪，采用原生的git方式一步步提交相应的改动，[关闭方式参考](https://nju-projectn.github.io/ics-pa-gitbook/ics2019/0.6.html)。

这里记录了PA实验过程中的思考和`git log`跟踪目录，具体可以通过`git reset`的方式，或查看commit记录回到当时提交的时间节点，查看相应的改动。查看改动的方式可以使用`git diff`。

谢谢食用。

（一刷走的是x86的路线）

# 基本环境

系统环境：虚拟机vbox + debian，其中vbox是6.0.14版本（不太建议，因为要安一些麻烦的拓展工具），debian是10.3.0版本。docker用起来比较麻烦，所以比较推荐使用vbox。主机环境为win10，cpu和内存影响不是很大。在一切就绪后debian默认应该是800\*600分辨率，偏小，建议调成1280\*800以上（在桌面右键Application/Settings/Display中设置）。

操作环境：tmux + vim。其中tmux在PA中有链接教学，相比于多终端我更喜欢使用tmux切换和分屏查看代码和执行程序。vim按照PA修改配置即可，够用就行。多依赖键盘而不是鼠标可以在一定程度上提高效率，但不强求，毕竟需要有一定vim的功底和命令行的基础。

# 通过PA能收获什么

其实依我个人的看法，凡是学习或涉及到**指令**和**程序**（包括计算机、单片机、FPGA，或者指硬件层面）的专业，都很有必要做一遍PA，因为它能够帮你迅速且全面地掌握系统、架构、编译相关的知识，通过实操使你的印象更加深刻，也充分锻炼了debug即解决问题的能力。除此之外，RTFSC、RTFM、RTFW等获取信息的能力也会得到极大的提升。这是从硬件与软件的中间层，即系统层这种极为基础的层次了解一个系统与环境的基本构成与实现，这对于相关专业都是极为有意义的。

# PA0

基础知识，跟着实验走即可。

# PA1

未完待续。

## PA1-3

> Reorganize the structure "CPU_state" (`nemu/src/isa/x86/include/isa/reg.h`).

这里需要查阅i386指令手册中的寄存器编码方案，具体在[INTEL 80386](http://css.csail.mit.edu/6.858/2013/readings/i386.pdf)中的31页（2.3.2节），也可以参考实验手册给出的x86寄存器结构。

寄存器分为3类，32位、16位、8位，且物理上不是独立的，即其是共享一块内存的。从命名方式也可以看出，如EAX是32位，其低16位是AX，AX中分为高8位（AH，H->high）和低8位（AL，L->low）。

**根据共享内存这一条件可以想到使用union**，通过将3类寄存器用union而非struct的方式定义，可以实现上述的寄存器设计。关于union可STFW获取更多信息。

在修改代码前先查看相应的测试代码(`nemu/src/isa/x86/reg.c`中的`reg_test()`)，查看assert的相关条件。可以看出其先随机给32位的寄存器赋值，然后通过assert判断32位寄存器中低16位和16位中的高低8位的值是否与对应的寄存器中存放的值相等。这与x86寄存器的设计以及上述思考是一致的。因此上述实现可以通过第一部分的assert测试。

此外在测试代码中还可以发现，其第二部分的assert测试是直接调用cpu.eax的方式访问相应的寄存器，即32位寄存器在cpu中有着类似cache的方式，有直接的变量对应，可以直接访问。因此回到`reg.h`的头文件中，需要再用一个union将相应的变量定义(eax等）与上述union定义的3类寄存器包含，使其也共享同一块内存空间。

如果此时直接运行测试，会发现assert会在第二部分的第二条语句触发。因为cpu.eax等的定义是`uint32`，相当于在union中连续声明8个uint32，了解过union共享内存的方式可以得知eax，ecx等寄存器在此时对应的都是同一个内存块（即`reg[0]`），因此eax可以pass第一个assert，但ecx由于对应的是eax的值，因此无法pass第二个assert。这里的解决方式很简单，只需要用一个struct将uint32的连续声明括住，定义一个大的结构体来表明其是一个整体而非互不相关的变量即可，此时的struct将与另一个union共享32\*8的内存空间，而在struct内部则是按顺序连续分配32字节的内存块，可以实现一一对应。

到这里就可以执行make run的指令并通过reg的所有测试，启动nemu了。

git log: `0a61a1821ee0a44b0171e5b154d8ecbccce748db`

小结：1、熟悉了x86指令集的cpu寄存器结构。 2、熟悉了union的原理和使用方式。 3、根据测试代码进行分析与修改。

>> 调用`cpu_exec()`时传入参数`-1`.

注意到其形参是`uint64_t`，传入`-1`意味着其可执行无符号64位数所支持的最大数的指令数（内置有一个循环，循环次数为可执行的指令数）。在C99中已有对64位整型数的支持，当给`uint64`赋值为-1时，其为`uint64_MAX - 1`，当然前提是平台支持64位。

## PA1-4

> 实现单步执行，打印寄存器，扫描内存的debug功能。（`nemu/src/monitor/debug/ui.c`）

单步执行只需要调用cpu_exec，传入相应的参数即可。

打印寄存器使用strtok分离出子参数，根据子参数进入打印寄存器的条件块，调用ISA的API即可。这里选择的是x86，因此需要在`nemu/src/isa/x86/reg.c`中完善相应api的代码。打印方式可以参考相应的测试代码，以及使用`reg.h`头文件中定义的函数和声明的变量数组。

扫描内存同样用strtok分别分离出两个子参数，这里先将EXPR暂时规定为十六进制而非表达式。访问内存数据的方式参考`nemu/include/memory/memory.h`中定义的宏和函数，直接调用即可(相关代码文件包括`nemu/src/isa/x86/mmu.c`以及`nemu/src/memory/memory.c`)。其中形参len指代的是字节的长度(详见`memory.c`)。输出格式参考命令`si`的输出。

git log: `6247203359e269e0e2a466579f03aaf93d78be9d`

小结：1、熟悉使用strtok处理命令的参数。 2、熟悉monitor中debugger的框架。

## PA1-5

> 实现算术表达式的词法分析（`nemu/src/monitor/debug/expr.c`)

代码实现可分为两部分，第一部分是定义，第二部分是功能实现。

在定义中，包括TOKEN类型值的定义，以及TOKEN规则的定义。根据词法分析一开始给出的表达式例子，在这里实现加（ADD）、减（SUB）、乘（MUL）、除（DIV）、十六进制（HEX）、指针解引用（DEREF）、小括号（LP、RP）、数字（NUM）、变量（VAR）、寄存器（REG）等基本定义以及根据其定义的equal符号（==），补充不等（NEQ）、非（NOT）、与（AND）、或（OR）等逻辑符号，最后用正则表达式定义相应的规则即可。

（不过此处为了简单起见，负数的处理在后续内容中暂不涉及，正如KISS法则，先实现简单的功能，让其能够run起来。在此基础上，遇到有更多功能的需求时也可以很方便的参考写出相应的代码。一开始就面面俱到只会让自己头大，并写出满目疮痍BUG频出的代码。）

**注意1**：由于循环中是按照规则定义的顺序来匹配字符串的，因此有冲突的正则定义需要有正确的顺序（比如HEX与NUM，NEQ和NOT等）。

**注意2**：在`enum`中定义TOKEN类型值的时候是顺序递增的，此处为了方便对常用的加（ADD）等符号直接用相应符号的ASCII值，定义完常用符号后需要恢复原来的排序值。

**注意3**：c的`regex`不支持`\d`正则匹配，可用`[0-9]`的方式来替代。

在功能实现部分，需要对表达式进行词法分析，简单来说就是将表达式中的所有符号和数字一一分离并保存。在框架代码中已经通过循环的方式用规则匹配并识别出了相应的token，后续只需要将这些token存至数组中即可。对于几种特殊的类型，即`HEX`、`NUM`、`VAR`、`REG`，需要记录其字符串，以便在后续对其值进行分析，而一般的符号只需要记录其符号类型即可判断其作用。

**注意4**：使用`assert`的方式拦截缓冲区溢出的情况。

后续可通过打印token数组的方式对实现进行调试。

git log: `e4a738a8ba160ecd490592268bf2706861217b65`

> 实现算术表达式的递归求值

在实验手册中已有BNF的解释说明与实现框架，只需要根据BNF的定义说明填充框架内的细节代码并补充部分必要的函数功能即可。这里通过传入`success`指针的方式来做相应的错误处理并提前结束求值过程，包括括号匹配的问题以及其他的一些非法表达式。

在做算术表达式求值前，通过`check_deref`的方式提前将乘（MUL）与解引用（DEREF）分开，具体的判断方式是解引用符号是第一个token或前面一个token是操作符而非数值。

负数求值选做留至2周目。（负数符号与解引用符号是类似的，识别方式相同，处理方式类似）

**注意1**：要考虑到只有一个解引用作为主运算符的情况，此时左式val1不存在，右式仅有一个数值或变量val2作为指针地址。（非运算符同理）

git log: `fb0f64b47a5854131d9e2dbd887dea4ffec34d61`

> 随机测试，实现表达式生成器

本身的框架和代码并不复杂，是很简单的功能，较复杂的结果计算与保存已经有相应的代码实现。而需要注意的要求有：

**注意1**：长表达式buf的溢出判断。

**注意2**：随机插入空格的方式。这里仅实现插入0或1个空格。

**注意3**：除0行为。由于结果是`uint32_t`即无符号的32位整型数，因此除法很容易带来除0的情况。为了减少这种无效的表达式，可以将生成除号的概率降低。

**注意4**：保证表达式进行无符号运算。

>> 为什么要使用无符号类型？

一个是溢出的问题，第二个是在表达式求值没有需要用到负数结果的情况。进行有符号运算可能会出现非法或溢出的问题。

举例来说，如果是`8 bit`的`unsigned`，在数据超过`2^8`时会取余（实际上是不断轮回到0直到其在表达范围内），包括出现负数时也会用`2^8`减去相应的值，可以将其看成是一个由数值范围组成的圆。而对于`8 bit`的`signed`，超出范围即溢出时不会做求余运算，在C中的定义是`Undefined Overflow`，由于最高位是符号位，因此会在截断多余的高位后进行符号判断，决定是否采用补码。

>> 除0的确切行为。

当出现除0行为的表达式，如`123 / (456 / (789))`，表达式生成器依旧会将其嵌入至求值代码中。此时求值结果会报`warning: division by zero`，而输出至input中的计算结果是上一次计算的结果，显然结果是错误的。因为除0行为的算式没有求值结果，表达式生成器便会用`result`变量原本的值输出。因此需要过滤除0行为的表达式，否则会出错。

**注意5**：除了需要过滤除0行为的表达式，溢出的表达式也应过滤，即求值“计算器”不处理溢出的表达式。

>> 过滤除0行为的表达式。

其中一个解决方案是在表达式求值的调用代码中操作。第二个解决方案是直接在表达式求值的代码中操作。归根结底都是对除0的报错做相应的处理。但过滤溢出行为只能采用后者的方法，通过返回特殊的值进行处理。

这里做过滤除0的工作，溢出过滤比较麻烦，这里暂不实现。

有两种方法可以过滤除0，一个是采用`system`的方式先执行一遍“计算器”程序，如果不是正常返回说明是无效的除0表达式，过滤后重新生成表达式即可。但由于system会输出合法表达式的结果，因此需要在后续将结果打印至文件中，即通过`FILE`的形式使用`fputs`，而非使用`printf`后在shell中调用`./gen-expr [amount] > input`命令将程序打印的输出保存至`input`文件中。

为了保留原本程序的特性，即使用`> input`的方式保存相应的结果和表达式，这里采用第二种方法，即对`popen`打开管道中的内容进行判断。通过代码调试和分析可以发现，不能直接调用`feof`来判断是否出现了除0等非法行为导致没有输出，因为对于合法表达式和除0表达式，`feof`均输出0，即没有到文件结尾。原因是即使程序没有输出，在`popen`的管道中仍会存在字符串的结尾`\0`。故这里通过`getc`的方式读取第一个字符，判断其是否是`EOF`来进而判断其是否正确执行了计算（从而过滤除0）。当然也可以先执行`getc`将第一个字符读出后再调用`feof`判断是否到了文件结尾，对于无输出的情况，其会将`\0`先读出，此时到了文件结尾`feof`会输出非0值；对于有输出的情况，即使只有一个个位数，其也会因为残余`\0`而未到文件结尾，`feof`输出0值。

需要注意的是由于使用了`getc`读取了第一个字符，因此需要重新回到文件开头读取正确的结果。

**注意6**：`rewind`不适合在`popen`中使用，在stack overflow中有相应的[问题](https://stackoverflow.com/questions/19523806/using-rewind-with-popen)，因为`rewind`是特殊的`fseek`，而`fseek`仅适用于文件而不适用于流，故`popen`的管道（也是流）是无法通过`rewind`的方式回到开头的。如果检查`rewind`的errno也可以发现这一点。事实上，由于管道是一小块内存缓冲，只存放临时产生的数据，因此无法使用`seek`。若要回到文件开头，这里采用的方式是关闭原来的管道并重新创建新管道。

>> 完善测试与实现和完善debugger中的表达式功能

在`input`文件中生成了表达式与结果后，在`nemu/src/main.c`中编写相应的测试函数，并在main入口主函数中调用该测试函数即可。根据测试的结果对原来的实现进行分析，修复隐藏的bug。

*通过这种方式确实找出了一个没报错的隐藏bug，这个bug在正常情况下也不会触发，但在表达式出现多个括号的情况下就可能出现。bug是在找主运算符中对括号的处理上出现了问题，具体可以通过`git log`以及`git diff`查看相应的改动。*

到此时PA1-5求值表达式的功能实现与完整测试已经完成，只需要在之前留空的PA1-4-debugger中补充相应表达式功能即可。包括：

1. 实现`cmd_p`的表达式求值功能。
1. 将`cmd_x`扫描内存中暂用的16进制数替换成`EXPR`即表达式求值，用所求的值作为扫描的内存地址。

git log: `ea31260b2bba64e609e0c39350926248f64e9bd1`

## PA1-6

> 扩展表达式求值的功能

这部分工作在PA1-5中已经基本完成。值得注意的是在PA1-5中寄存器的求值处理在这里需要做一点改变，将其抽象至ISA中，直接调用ISA的API来获取相应的值。具体的实现工作放在ISA的API中去做。

git log: `c0abf3e3d6cc8aa3352d9121f2e8013810daf7c6`

> 实现监视点池的管理

主要是链表的插入与删除操作（为了方便删除操作的参数使用监视点序号n）。(`nemu/src/monitor/debug/watchpoint.c`)

>> static的含义，为什么使用。

在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

> 实现监视点

首先需要确定监视点所监视的对象，即在监视点结构中需要加入什么监视变量。这里需要记录的对象有表达式以及表达式的值（或称为未发生改变的旧值）。(`nemu/include/monitor/watchpoint.h`)

随后需要新增监视点对应的功能函数，包括两方面：(`nemu/src/monitor/debug/watchpoint.c`)

1. 每执行一条指令，需要调用函数1来对监视的表达式求值，比较其是否发生变化。若发生变化，则暂停程序。
1. 在调用命令`info w`时需要调用函数2，以打印监视点中的详细信息。

确定好需求和目标后实现起来并不困难，只需要按照要求完成即可。

最后在PA1-4的debugger中更新与监视点相关的功能。（`nemu/src/monitor/debug/ui.c`）

需要注意的是，因为要在执行指令的过程中检查监视点的值是否发生变化，因此需要在`cpu_exec`中植入与监视点相关的检查代码。（`nemu/src/monitor/cpu-exec.c`）

git log: `bbba03087a58c8fa921859c2fc38580789fe6c2f`

> 调试工具与原理

一些很有用的调试方式与建议，GDB也很强大。

>> 在GDB中运行触发段错误的程序，会提供什么信息？

关于段错误可以参考[百科](https://baike.baidu.com/item/%E6%AE%B5%E9%94%99%E8%AF%AF/7896410?fr=aladdin)，GDB会提供以下信息：

1. 程序触发的错误类型（段错误），接收到什么信号而终止的程序（可以通过man 7 signal查询对应信号）。
1. 触发错误的具体位置，即源文件的行数、所在的函数、函数的地址。
1. 触发错误对应行的详细代码。

可以看出GDB的强大作用，在`assert`和`printf`不管用的情况下，GDB是很好的选择。

> 断点

该篇提到了用监视点来模拟断点的功能，以方便查看程序在某一时刻的状态。值得注意的是，断点地址仅能设置在每条完整指令的开头，设置在中间时会跳过，实际上用`si`单步执行指令时也可以发现这一点。当然这是合理的，且不论实际的编译调试就是如此，更深入地看，不同的指令有不同的字节长度，而每次执行完指令寄存器PC都会跳到下一条指令的地址，而不是下一个字节。

>> 提高断点的效率

设置断点会明显降低NEMU执行程序的效率，这是显然的。因为每执行一次指令都需要检查所有的监视点，而检查的过程包括对表达式的一次求值，这个过程相比于执行单条指令是慢很多的，因此会大大降低执行效率（甚至可能是10%的时间在执行指令，90%的时间在检查断点）。可以很容易的发现断点的效率之所以非常低下，归根结底是因为断点是用监视点来模拟的，为了解决这个问题，则需要从根源着手。监视点本身相比于断点是低效的，因此需要将断点与监视点的功能分离开来。类似于debugger中x86的`int 3`断点中断指令，在设置断点的时候，需要将断点目的地址的数据保存起来，然后将指令的第一个字节码替换成对应的中断指令（`0xCC`)，由CPU自己产生中断而不需要像监视点一样每条指令都进行扫描。

具体方法不难，只需要设置对应的断点地址，用框架内置已实现的`vaddr_read`将地址内的指令数据读出，再用`(data & 0xFFFFFF00) | 0xCC`(因为这里一次读了4个字节)后`vaddr_write`写回即可，遇到断点暂停后再将原数据写回（这一步则需要在`cpu-exec.c`中完成，与监视点的暂停实现类似）。

>> 一点也不能长以及随心所欲的断点

`int 3`指令长度是1个字节，这是必须的。指令的长度变成了2个字节后文章中所说的断点机制就不再能正常工作了，并非指的是程序无法在断点处停下，而是如果需要在单字节指令处设置断点（如汇编中的`DEC/INC`），意味着下一条指令的首字节会被覆盖而改变原意，导致无效的指令，具体案例可以参考[这里]的**More on int 3**小节。

如果把断点设置在指令的非首字节，即中间或者末尾，那么在GDB中程序并不会在断点处停下，这与我们之前实现的监视点形式的断点是类似的。原因在前面已经提到，CPU在执行指令的过程中会先读PC寄存器指向地址的第一个字节，即操作码，在未遇到`int 3`这类中断暂停的单字节指令时程序会继续执行，而植入在中间或末尾的断点只会改变操作码后面的字节数据，造成错误的结果。

举个例子，当指令为`mov ebx, 1`时，机器的字节码为`bb 01 00 00 00 | mov $0x1, %ebx`，这是一个5字节长度的指令，如果将首字节的`0xbb`替换为`0xcc`，将引入一个`int 3`断点中断。当断点设置在非首字节，如将`0x01`替换为`0xcc`，则指令的原意将发生改变，且不会触发中断暂停程序。

## PA1-7

使用的ISA为x86，按照假设需要在调试上花费时间75小时。简易调试器花费25小时，节省50小时，事实上使用GDB直接调试客户程序需要的时间可能更长，相比于简易调试器而言更难且效率更低。

通过查阅[x86手册](http://css.csail.mit.edu/6.858/2013/readings/i386.pdf)可以得到以下问题的答案：

1. EFLAGS寄存器中的CF位是“Carry Flag”，是进位或借位标志位，在计算前后会对其进行处理。具体解释在3.2节，EFLAGS寄存器结构图在2.3.4节的图2-8。
1. ModR/M字节是用于指示操作数是在寄存器中还是在内存中。具体参考2.5.3节。
1. mov指令的具体格式是MOV [DEST], [SRC]。具体参考17.2.2.11节。

shell命令可以统计代码行数，包括除去空行时的行数。命令为：`find . -name "*.[ch]" | xargs cat | wc -l`，除去空行则在`wc -l`前加上`grep -v ^$`和管道即可。至于在PA1编写了多少代码，只需要通过`git log`以及`git reset`回到相应的历史版本即可，或者通过`git checkout master`回到最初的pa master分支，因为此时还没合并分支，即分支pa1是超前的，因此可以通过比较分支pa1的代码行数以及分支master的代码行数来统计在PA1中编写了多少代码。可将上述统计代码行数的命令加入Makefile中。

git log: `6ecf9bc47235bb49b40768a017fed9d5146bb816`

在GCC的编译选项中，`-Wall`和`-Werror`分别是打开GCC的所有警告，以及将所有警告当成错误进行处理。使用这两者可以对编译过程中可能存在的问题进行检查，通过error的方式找出这些问题，而不会被忽略成为隐患。

到这里PA1的内容已经结束。基本的调试与模拟工具NEMU已基本实现，为之后的PA打好了基础。

# PA2

未完待续。

## PA2-2

> RTFM，找手册指令集内容的位置 （x86）

每一条指令具体行为的描述： P255标题为17.2.2.11 Instruction Set Detail。之后很长一段都是描述各个指令的具体行为。

指令opcode的编码表格： P412标题为Appendix A Opcode Map。附录开头给出简写定义，P414-P416给出编码表格。

> RTFSC2, 整理一条指令在NEMU中的执行过程

1. 取指令，在`/include/cpu/exec.h`中调用函数`instr_fetch`，通过访问相应长度（`len`）的内存地址（`pc`）将指令（的值，即机器码）取出并返回。

1. 译码与执行，根据取出指令的机器码，通过翻译其操作码`opcode`来决定指令对应的具体操作`OpcodeEntry`元素。在`include/cpu/exec.h`中的`idex`函数抽象出了译码与执行的两个过程，从译码查找表中取得的元素（或称之为辅助函数，包含译码辅助函数和执行辅助函数）会被作为参数进行调用。

1. 译码的具体细节，找出操作码后还需要找出操作对象，这就涉及到了译码辅助函数，在`include/cpu/decode.h`中统一通过宏`make_DHelper`来抽象定义，不同的译码辅助函数负责单独一种的操作数译码。为了进一步解耦出操作数译码和指令译码，还额外使用了宏`makeDopHelper`来专门抽象定义操作数译码的辅助函数，该宏和相应的函数在`src/isa/x86/decode/decode.c`中定义（因为这是ISA相关的内容，具体原因请查看讲义的蓝框背景说明）。

1. 执行的具体过程，在`include/cpu/exec.h`中也定义了相应的执行辅助函数的宏`make_EHelper`，而执行辅助函数内具体通过RTL（寄存器传输语言）指令来真正执行对应的指令。关于RTL的行为定义，在`include/rtl`中包含了`rtl.h`以及`c_op.h`，对应的RTL寄存器则在`include/cpu/decode.h`以及ISA相关的`src/isa/x86/include/isa/reg.h`中定义，还有供中间操作的临时寄存器(`src/cpu/cpu.c`)。

1. 更新PC，根据执行指令的长度，更新`pc`至下一条指令的地址。

> 运行第一个C程序

>> 报错信息的来源

在nemu的文件目录下查找源码中含有的关键字即可，`find ./ -type f | xargs grep -n "invalid opcode"`可以发现是在`src/isa/x86/exec/special.c`的第17行输出的报错信息。更具体的，后续调用的`display_inv_msg`的invalid函数则是在`src/cpu/inv.c`中定义的。

>> 指令的实现

首先根据上述RTFSC2的问题可以知道执行指令的入口在`idex`函数处，这部分会调用两个辅助函数来完成译码与执行两部分工作。而在这之前我们需要考虑的是操作码的识别与索引`opcode_table`找出相应的`OpcodeEntry`元素这两个过程。通过查看`src/isa/x86/exec/exec.c`的`isa_exec`函数我们可以发现，操作码的识别（即取出当前pc指向地址的第一个字节作为操作码），以及操作码的译码表索引（源码中为`opcode_table[opcode]`）已经在nemu的框架内实现。跟着源码前进我们可以发现我们需要补充实现的部分为opcode_table的填充，为其补上相应的`OpcodeEntry`元素，更准确的说，通过查看`OpcodeEntry`元素的结构（在`include/cpu/exec.h`中），我们需要给出该操作码对应的两个辅助函数以及相应操作数的宽度。

KISS法则，这里仅实现dummy中必要的指令。注意到`include/cpu/exec.h`中定义的宏`IDEXW`与`IDEX`可以很方便地初始化生成`OpcodeEntry`元素，仅需要填入对应操作的函数名字与操作数宽度。此外还有`EXW`, `EX`和`EMPTY`。

接下来查看反汇编结果，发现其涉及的操作码有（这里省去0x）bd, bc, e8, 90, 31, c3, 55, 89, 83, 68, d6, eb，其中框架代码未实现的为e8, 90, 31, c3, 55, 68, eb。不过90是`nop`即无操作，eb对应的`jmp`是在`(bad)`后面，即函数无法正确返回时执行的操作。因此如果仅仅是让dummy程序跑起来，只需要实现e8, 31, c3, 55, 68即`call`, `xor`, `ret`, `push`。其中`push`有两种形式，寄存器和立即数。此外，83的`sub`虽然表中已经实现，但需要额外在`src/isa/x86/include/isa/reg.h`寄存器结构体中添加EFLAGS寄存器。

译码辅助函数的实现在`src/isa/x86/decode/decode.c`中。实现的过程中需要参考之前提到的i386的opcode编码表格和指令的具体行为描述，且仔细思考后会发现慢慢能看懂P412之后的几个表格。这里给出各个指令除填表外涉及到的函数。（在`src/isa/x86/include/isa/decode.h`头文件中列出了所有decode函数）

1. 实现`call`，i386（后略）的P275可以看到e8对应的rel32的指令，找到Operation部分发现需要先将当前`pc`压入栈中保存（事实也是如此），因此需要先实现压栈的rtl。

1. 实现`xor`。P414可知操作码31涉及`make_DopHelper(G2E)`，已实现，填表时直接调用即可。注意到`xor`得出的结果需要覆盖（replace）第一个操作数，在这里指的是`id_dest`的内存地址/寄存器的值，而非操作数的临时内容`val`。部分EFLAGS也需要更新。

1. 实现`ret`。直接调用ret的执行辅助函数即可，无需额外译码辅助。

1. 实现`push`。涉及`make_DopHelper(I)`和`make_DopHelper(r)`，均已实现，可以直接调用，填表即可。值得注意的是，由于rtl支持的栈操作`push`与`pop`均使用4字节，因此在调用`exec_push`时需要先做符号扩展`rtl_sext`，将操作数扩展至32位。

1. 实现`sub`。涉及`make_DopHelper(SI)`, `rtl_sext`。注意到在`make_DopHelper(SI)`已经默认参数`load_val`为`true`了，直接执行了`rtl_li`操作，且`op->simm`为`int32_t`类型。

执行辅助函数的实现在`src/isa/x86/exec`整个文件夹中，包括`special.c`给出了`nop`, `inv`, `nemu_trap`等特殊操作；`control.c`给出了`jmp`, `jcc`, `jmp_rm`, `call`, `call_rm`, `ret`, `ret_imm`等控制操作；`system.c`给出`lidt`, `mov_r2cr`, `mov_cr2r`, `int`, `iret`, `in`, `out`等系统操作；剩余`arith.c`为数学操作，`logic.c`为逻辑操作，`data-mov.c`为数据移动相关操作。很多都留空需要实现相关的代码才能正常运作。

在译码表填充完毕后，剩下的事就是找到相应的RTL指令函数（`include/rtl/rtl.h`以及`src/isa/x86/include/isa/rtl.h`），实现执行辅助函数调用的相关部分，然后运行。

额外需要注意的是，`sub`或之后要实现的`add`都会涉及到`CF`进/借位位和`OF`溢出位的判断。其中`CF`主要针对的是无符号数，而`OF`主要针对的是有符号数。无符号数不会发生溢出问题，只会出现进位，即只管`CF`；有符号数“不会”出现进位（因为最高位已经是符号位了），只会发生溢出问题，即只管`OF`。事实上，有符号数也会出现进位（发生在两个负数相加且未溢出时），此时进位得到的是新的符号位，增加了负数表达的位数，但实际上该进位位没有任何意义。

`CF`进位发生在结果比操作数小，借位发生在结果比操作数大的情况下。`OF`溢出发生在两个源操作数符号位一致，但结果与源操作数符号位不一致的情况下。

此外，参考i386手册会发现部分情况下`src`操作数需要做符号扩展`sext`(在`dest`和`src`位数不同的时候），但在实际执行操作（执行辅助函数）中并不需要额外再做这一步，因为这一步已经在操作数译码辅助函数中完成了（`Make_DopHelper(SI)`），凡是涉及到符号扩展的都会调用`SI`的方式读取立即数。（如果细心点，可以发现在`exec.c`的译码表中，只有6b和83两个操作码涉及到了`SI`操作，而83对应的是gp1的指令表，gp1中包含了所有涉及到符号扩展的数学/逻辑指令，他们对应的操作码实际上也就是83）

git log: `68b6b5a0a1f2f0ca8b72006ec4fa2b60a38b4e3a`

## PA2-3

> 运行更多的程序 （完善nemu中的代码，实现更多的指令）

没什么好说的，之前已经走过一遍流程了，无非是对未实现的译码、执行辅助函数做填空题。值得一提的是，为了边做边测找问题，而不是全部实现了才进行测试，这里有按一定的顺序编译程序查看其反汇编的机器码，然后对应实现相应的指令（顺序不固定，但最好是从简单到复杂，从少到多）：

1. `add.c`。需要实现的指令数量不大，且实现完后可以将涉及到指令的源码都基本过一遍，有一定的认识和理解，后续再实现其他指令时可以更快更高效的完成。主要有`setcc`、`inc`、`add`等，对应的git log为`0e05a0ce2875d239d6ae6138c6472f17b6b0d503`。

1. 基本没啥问题了，直接先撸掉操作码的译码表，包括group部分，中间遇到什么未实现的执行辅助函数再跳到`exec`文件夹中去实现。从头到尾一个个去实现，实现完了再去做各个程序的总测试，看报错消息来修正bug。

值得注意一下的是，先前我们已经分析了一条指令的执行过程，其中**取指部分只需要完成译码表的部分**，操作数译码部分在框架中和之前的`dummy`后已经全部实现，**执行部分则需要到`isa/exec`文件夹中去逐个将`.c`文件中的函数全部实现**，rtl部分在`add.c`程序执行完成后已经基本完成了。此外，由于nemu中不涉及segment，因此诸如CS、DS、ES、FS、GS等带S的segments所涉及的指令我们也无需去实现。

（小陷阱：group中的不全是`EX`执行辅助函数，group3在译码阶段会先调用`E`读取`modR/M`到`id_dest`中，这对于group3中的绝大多数指令是没问题的，都是单操作数，但其中第一个指令`test`如果翻阅i386手册的指令解释会发现其没有单操作数的例子，即其仍需再读入一个操作数。在`decode.c`中也可以找到`test_I`的译码辅助函数，注释解释其是专门用在group3中的`test`的。因此group3中的`test`指令仍需调用一次`IDEX`而非只用`EX`。这个小陷阱是测试出现“未实现指令”报错时，查看日志log发现的，你也可以去试试看这个debug找错的过程：group3中的`test`指令使用`EX`，测试的程序对象为`leap-year`，`run`之后会出现“1000be处未实现指令（d8）”，而实际上d8是没有指令的，因此可以初步判断是之前的指令读取操作数的时候发生了错位（读多或读少），找到`build/nemu-log.txt`对照`build/leap-year.txt`的反汇编文本就可以发现问题出在哪个位置的哪个操作码上。）

git log: `f106a6a2230b41fdfa3555ee7b78a269ac521aa6`

>  实现常用的库函数

实际上只有两个文件需要实现其中的部分函数，也不需要再考虑nemu等底层硬件的调用，而是在C语言的层面上实现一些简单常用的库函数，没什么太大的难度。唯一有一点难度的是需要`man stdarg`查看相关宏如何调用，以及`man printf`查看相关函数的调用参数以及返回值是什么，但实际上翻到最底下看`return`和`example`部分就能快速入手了。

（注意：void指针加减1均移动一个字节，因此`memcmp`这里有两种写法，一个是先转换成`char *`或`int8_t *`再做加减，另一种就是先对`void *`做加减再做类型转换，效果是一样的。截取computer programming的Pointer章节原话则是会默认将其当成`char *`处理）

这一小节的目的是为了说明这些库函数实际上是与硬件无关的，只是将一些循环和基本操作封装在一个函数中，这些函数再封装成库，方便其他程序的调用。而无论那些程序是运行在x86还是mips上，都不会影响这些库函数的表现，因此我们仅需要实现这一份代码就可以用在所有的架构上了。

>> 免责声明部分

我们可以看到很多函数虽然没有实现，但都写好了返回值保证这些库函数可以执行。但目前我们用不上所有的函数，只需要实现部分即可。而免责声明提出定义了API不一定来得及把它们全部实现，但将来用到没有实现的库函数debug的时候会非常痛苦，需要花费大量时间去调试，我们需要的是当我们用到了某个没有实现的函数时能够及时提醒。因此如果查看git log的改动可以发现，我们可以在暂时不想实现的函数中加上`assert(0)`来引发报错，将来如果用到了这个函数，我们可以在报错信息中找到具体的文件和行数。（类似的，也可以自己定义一个输出宏，输出相关的未实现信息）

git log: `67e71695120d00ca2e4825276efd235ae88c0429`

## PA2-4

>> DiffTest

首先是需要检查寄存器排列的顺序是否满足API的约束，对比文件为：`nemu/tools/qemu-diff/src/isa/x86/include/isa.h`与`nemu/src/isa/x86/include/isa/reg.h`。其次还可以查看`nemu/src/isa/x86/include/isa/diff-test.h`中定义的`DIFFTEST_REG_SIZE`为9，即这里只检查8个通用寄存器和PC的值是否相同，eflags是不参与检查的（事实上也没办法检查，因为我们在nemu中实现的标志位有限，正常对比结果一般都是不同的）。

接着实现DiffTest中的ISA相关的`checkregs`函数，并在`nemu/include/common.h`中将宏`DIFF_TEST`打开，重新在nemu文件夹下make即可。

如果之前实现的都是正确的指令，那么每次执行完程序都会输出“HIT GOOD TRAP”，并自动退出nemu以及qemu。此外也可以看到输出的字段中有“Differential testing: ON”字样。

（另外，如果想看一下DiffTest的效果，可以将译码表中的31对应执行辅助函数的`xor`改成`and`，然后在nexus-am的cputest中测试add程序。这时候nemu会及时在寄存器值不一致的时候打断程序，并输出所有通用寄存器和对应下一个pc的值，以及发生异常中断的pc位置，此时可以去build中找到程序对应的txt反汇编码，找到相应pc位置，查看其指令，从而定位错误的大致位置。）

git log: `1a50d393c007af5fd501d2bfe3db6a2cdfca98e8`

## PA2-5

> native如何实现main函数的参数传递

提示：先看`./src/main.c`，再看`./include/amtest.h`。

> 串口 - 运行Hello World

值得注意的是由于在`pio_read`以及`pio_write`中（`nemu/src/device/io/port-io.c`）会调用`nemu/include/device/map.h`中的`find_mapid_by_addr`函数来获取map的相应index，而在这个函数中已经调用了`difftest_skip_ref`函数（在未定义宏`DIFF_TEST`时是空函数，详见DiffTest部分）来跳过与QEMU的检查，因此我们不需要在实现`in`与`out`指令时额外调用`difftest_skip_ref`函数，这样代码会显得整洁很多，也将测试与指令部分完全分离了。

git log: `xx`

> 时钟 - 实现IOE

跑分进入相应文件夹`make run`即可。这里记录一下第一次跑分结果：（i5-10210U @ 1.60GHz，虚拟机仅分配单核处理器）

1. dhrystone: 133

1. coremark: 405

1. microbench: 601

当然，这里为了能让microbench的MD5测试通过，需要回到nemu中去实现d3-group2中第一个的`rol`指令。这个函数没有TODO的提示，需要我们自己添加，由于做的是位循环的操作，因此我们将执行辅助函数添加至`logic.c`中，别忘了在`all-instr.h`中加入该函数的声明。此外，参考`shl`，标志位`CF`和`OF`在nemu中不需要更新。

git log: `xx`

> 键盘 - IOE2

MAP宏实际上就是多个宏之间互相作参数调用，最后实现一个enum的键值声明。对于检测多个按键，扫描矩阵可以检测出哪些键处于被按下的状态，而按键码有先后顺序，会以后来的按键码为准一直停留（事实上你不管在什么机器上，同时按下两个键后后一个键会一直延续按下的状态），如果是要判断组合方式，则会把之前按下但还没收到松开信号的按键记录下来，与当前按下的按键码一起组合成相应的功能。在nemu中（`src/device/keyboard.c`）有维护一个循环队列来保存相应的按键码信息。IOE2的实现蛮简单的，只需要把两个代码调换一下位置即可，做一定的操作即可。

git log: `xx`

> VGA - IOE3 + IOE4

涉及到的文件主要有：

1. `nexus-am/am/include/nemu.h`，看端口的宏定义。

1. `nexus-am/libs/klib/src/io.c`，有4个实现VGA要用到的函数。

1. `nemu/src/device/vga.c`，VGA的硬件实现。其中回调函数`handler`未实现。

1. `nexus-am/am/src/nemu-common/nemu-video.c`，VGA抽象寄存器信息的读取与写入，未正确实现，VGA的初始化也未实现。

具体改动看git log。

（由于使用了memcpy函数，需要在之前PA2-3提到的`string.c`中实现，实现后顺便对原有的strcpy简化了）

git log: `xx`

> 可展示的计算机系统

运行程序到相应的文件夹下`make run`即可。其中LiteNES（先`make`再`make run`）运行后加载的是pacman吃豆人游戏，但很可惜目前只有6FPS，非常卡。按照`FPS/跑分`指标，仅有`6/601 = 0.01`，显然在LiteNES上单位计算能力贡献的FPS非常低，本身的性能很差，有极大的优化空间。

>> LiteNES如何工作

读了LiteNES的`cpu.c`的代码后我们不难发现，其大体结构与nemu是很相似的。同样是取指与译码，然后最后执行。主要的工作流程可以只看`cpu_run`函数以达到窥一斑而知全豹的效果。首先会通过`memory_readb`函数读取`pc`所指向地址的第一个字节，作为操作码`op_code`，然后用该操作码到`cpu_op_address_mode`里面检索并调用相应的译码函数（在`cpu-addressing.c`中），并在译码之后到`cpu_op_handler`中调用相应的执行函数，便完成了一个指令。这里唯一不同的是，其`cpu_run`的参数是周期而非指令数目，在nemu中是执行指令的数目作为循环，而在这里是用指令周期数作为循环，而每个指令消耗的时间周期是不同的。

>> 必答题

1. RTFSC：参考[PA2-2](#PA2-2)。

1. 编译与链接：首先我们需要掌握`static`和`inline`的作用。由于语言是C这里没有类的概念，因此`static`修饰的是静态函数，这意味着该静态函数不能被其他文件所使用，而只能在该文件中调用（虽然在我们看来是被执行辅助函数调用了，至于原因则是与`inline`的修饰有关），并且在其他文件中可以定义相同名字的函数而不会发生冲突。再来看`inline`，在C99中`inline`是向编译器**建议**将被`inline`修饰的函数以内联的方式嵌入至调用这个函数的地方，或者换言之，相当于在调用部分将函数的代码一行行重写一遍而不是跳转到函数中去执行。

那么`static`和`inline`在这里一起用的作用是什么？或者说有什么好处？

我们先明确一个前提就是这些`static inline`函数都是在`rtl.h`头文件中定义的，而不是源码文件`.c`，这是因为我们想在其他地方用到这些函数而不是单单只在这个文件中用到，因此我们在这里不用考虑函数作用域的问题。

好处主要是体现在`inline`上。对于一般函数，首先跳转需要访问内存地址，而且还要将一些参数压栈保存现场，指令数量也会增多，显然速度相比于嵌入的内联函数会慢很多。不过这也是有代价的，`inline`的嵌入会使代码量增加，换言之，会占用更多的内存，这是明显的以空间换取时间的做法。因此正如前面黑体标记的**建议**，编译器会根据内联函数的代码量、参数量以及调用次数来决定是否内联嵌入。总结来说，`inline`只能向编译器提议，而最后是否内联还是得看编译器的优化策略。如果决定不内联嵌入，那么`inline`修饰的函数与普通的函数无异，一样是通过内存地址跳转调用函数的。

那这时候就会有一个问题：如果没有用`static`来限定`inline`的函数，那么这个函数在编译时就会被认为是全局的。但刚刚也提到我们在编译完成后如果不看反汇编的代码，是无法确定一个函数是否是内联函数的。而由于内联函数一定是要放在头文件当中实现（而不是声明，后面会解释为什么）来给其他源码文件使用的，因此如果这个函数没有被编译成内联函数，又被多个源文件`include`库所包含，那么就会引发函数重定义的问题（不同编译器或不同的优化级别很有可能会报错）。因此这里`static`的作用就是维护代码的健壮性。

用更通俗易懂的例子解释就是：我们知道源码文件的前几行一般都是`include`各种库，这些库里面被用到的函数实现（而非声明，具体看后面）就会在这些函数的开头被隐式的定义并实现一遍。这就好比有三间屋子要用电，他们按照一个标准给自己的屋子都造了一个电机，那么这里就有3台重复的、一摸一样的电机出现，但实际上我们只需要在外面有一个总的电机（或称为电站），同时给这三个屋子供电就可以了。`static`就是这个作用，将函数限制在头文件当中，而不会出现在多个源码文件中重复定义的问题。因此**确定会被多次用到的、在头文件中实现的函数最好前面加上`static`进行修饰。但`static`会为这个函数预先分配静态空间，因此如果函数没被用到则会浪费这片空间，也会使程序变得笨重，这并非是include的库本意**。而`inline`函数就是这其中最显著的例子。如果编译器将所有用到的`inline`函数都内联嵌入，那么`static`不会有任何影响；但一旦有某个`inline`函数没有被内联嵌入，又没有用`static`修饰限制，那么就会引发之前提到重定义问题。这就好比如果某间屋子要用独立的电机，我们可以搬一台给他，但如果他们为此而自己造电机，那么就会浪费很多资源，且可能会带来某些冲突的问题。

于是我们可以得出结论，在头文件中用`inline`的时候务必要再加上`static`，事实上在linux的内核中也是这么做的。而`static inline`应用的场景一般都是其函数语句较少，且不是递归函数时，为了加速程序，避免频繁调用函数的跳转与压栈带来的时间开销，会用一定的内存去换取更高的效率。尤其是在一些非常基础的操作中（在nemu中则是rtl操作）。

现在还剩的一个问题就是：为什么要在头文件中实现（`inline`）函数呢？这就涉及到C的编译器原则了，编译器会以c文件为单位逐个编译obj，每个c文件的编译是独立的，该c文件用到的外部函数都在编译时预留一个符号，只有等到所有obj生成后链接时才会给这些符号相应的函数地址（链接脚本决定地址），所以其他c文件编译时只会看到这个函数的声明而无法知道它的实体（实现）。这意味着如果不在头文件中实现`inline`函数，它就会像普通函数一样编译，然后等链接的时候再给其他c文件填入该函数地址，这就做不到内联展开。所以要内联的话则必须在每个用到它的c文件中都能看到其实现，换言之，其必须在头文件中有相应的实现（而不是在`.c`文件中）。

**总结：这类希望全局使用又希望增加效率的函数会在头文件中通过`static inline`的方式实现。**

最后回到题目问题。去掉`static`的问题之前已经分析了，但编译器并不会报错（这是因为我去掉的是`rtl_li`，函数只有一句，应该是编译器在所有调用该函数的地方都采用了内联嵌入的方式，所以没有冲突）。去掉`inline`则会降低该操作的执行速度，但不会触发错误（因为仅仅是静态函数）。两者都去掉则函数相当于普通的函数，而这个函数又是在头文件中实现的，这时候编译器是一定会报错的，报错的结果也正如我们前面分析所说，"yyy.o: in function `xxx`: multiple defination of `xxx`. first defined here (rtl.h)..."，所有用到该函数的.o（obj）文件都会定义并实现一遍（因为include这个头文件），显然这是冲突的。

想要证明`static`则需要查看反汇编的代码和分析.o文件（是链接了静态函数的地址而非定义实现一遍）。想要证明`inline`则看反汇编代码是否实现了嵌入，而不带`static`是否会出问题分为两个方面，一个方面是如果函数中引用了另外一个`static`函数，则该函数也需要用`static`进行静态修饰，否则报错；另一个方面是如果用在了复杂的函数中，可能不会作为内联函数嵌入，那么就会出现前面提到的未用`static`限制的重定义问题。两者都不用直接会报错，可以证明我们的想法。

1. 编译与链接2：这题其实是上个问题的一个小拓展，除了加深对头文件以及`static`的理解外，还加深了对`volatile`关键字的理解。具体关于`volatile`的解释可以STFW获得，概括起来就是防止优化，保证变量不会被缓存，而是强制访问内存。

我们现在想要得知重新编译后的nemu有多少个`dummy`变量的实体，最简单的方法就是用`grep`在所有的`.o(obj)`文件中查找。上一题中也有提到，所有的c文件都会逐个编译`obj`，生成对应的实体对象。因此这里我们可以在`/nemu`目录下使用命令`find build | grep '\.o' | xargs grep 'dummy' | wc -l`来查看nemu中含有多少个`dummy`变量实体。

在编译前用该命令是0个。

`common.h`添加`volatile static int dummy`后，有38个实体。

继续在`debug.h`添加`volatile static int dummy`后，有76个实体。不过我们这里需要对命令有一个小小的修改：`find build | grep '\.o' | xargs grep -a 'dummy' | wc -l`，需要在最后一个`grep`中加上`-a`参数，可以通过`grep --help`或`man grep`找到这个参数的含义——把二进制文件当成文本文件来处理。因为之前我们不需要知道二进制的文本内容，有实体就是1，没实体就是0，那时候的`grep`也仅仅是输出哪些二进制文件匹配（包含）。但这里不同，由于二进制文件数量不会变，但内容里可能会多出一个`dummy`实体，所以我们需要把二进制转换成文本后再进行匹配（否则还是38个，因为就这38个文件里包含）。修改后的指令指出有76个实体。

我们与之前的实体数量进行比较可以得知，这两个头文件中定义的`volatile`的变量是独立的，即给他们分配的内存空间地址是不同的，访问时自然也是对应的不同的内存（注意一定是内存而不是寄存器，这是`volatile`的特性）。因此实际上在这38个`include`了这两个头文件的源文件编译后，生成的二进制文件(`.o`)中，每个文件都有两个`dummy`实体，这两个`dummy`实体指向的内存地址是不同的，所以也不会出现重复定义的问题。

对两处变量都进行初始化后，则会引发报错，报错的原因是重定义。但对其中任何一个取消初始化（即一个初始化，另一个不初始化）则不会出现这个问题。这里我们可以确定，一旦对两者都进行初始化时，编译器会检查到两者是相同的名字，此时便会引发重定义的错误。之所以这里有这个问题而之前不会出现（以及只定义一个的时候不会出现），我个人的理解是未初始化时，编译器会为变量分配一个独立的内存地址（因为此时没有具体的指定其内存地址或指向），访问这个变量时也一定是访问其对应的内存（`volatile`作用）。但当我们对其初始化时（这里是赋值为0），意味着什么？意味着其被指定了内存地址，之后访问这个变量时也是到这个内存地址中去。什么内存地址呢？装载这个数值0的内存地址。换言之，这个数值的内存地址与`dummy`变量进行了“绑定”。如果我们存在两个相同名字的`dummy`变量，且都初始化了，那么就会引发重定义的问题，因为我们在第一次定义的时候就已经为这个变量指定了确定的地址，在第二次定义的时候就会发现之前已经定义过并为其指定了地址了，这里就变成了重复定义（或者说发生了同一变量不同地址的冲突）。而我们不初始化的时候，是没有为其指定地址的，此时这两个`dummy`是独立的（因为在两个不同的头文件中），或者说我们可以理解为其已经是不同的变量了，因此其最后分配不同的地址时不会发生冲突。

具体可以自己简单的做一些小测试然后去查看变量的地址（写一个简单的`main.c`测试）。这里给个简单的实例，我定义了一个`mytest.h`的头文件，里面的代码是这样的：

```
#ifndef __MYTEST_H__
#define __MYTEST_H__

#include<stdio.h>

volatile static int dummy;

void output() {
    printf("%p\n", &dummy);
}

#endif
```

然后在`main.c`中引用了该头文件，并且在主程序中：

```
volatile static int dummy;
printf("%p\n", &dummy);
output();
```

这时候程序的输出是`000000000040c038`与`000000000040c034`，可以看到这两个`dummy`变量对应的内存地址是不同的。如果我们将`mytest.h`中的`dummy`初始化为1，结果变成`000000000040c034`与`0000000000408010`。

那么这几个问题想告诉我们什么呢？我觉得是**在定义`volatile`变量时，一定要对其初始化，防止出现重复变量名的情况，防止其变成一个“野”易变变量（类似“野”指针），出现未定义行为UB**。

1. 了解Makefile：略。Makefile需要对其语法和结构有一定的了解，这里只能大概看出其主要工作方式是`find`出所有的`.c`和`.h`文件后，将文件名或目录名保存在相应的变量里，读取与调用相应的参数联合编译。

PA2到此结束，在PA2中我们实现了一个简单的计算机，能处理指令，有基本的运算能力（图灵机）和输入输出的能力，包括时钟、键盘和图像的基本功能也有了。

# PA3



# 参考资料

[ICS2019-PA](https://nju-projectn.github.io/ics-pa-gitbook/ics2019/)
[源码分析](https://stardustdl.github.io/ProblemSolving/2018/10/05/solving/nju-icspa-analytics-nemu/)